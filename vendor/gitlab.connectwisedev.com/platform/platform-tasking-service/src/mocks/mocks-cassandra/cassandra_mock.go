// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.connectwisedev.com/platform/platform-tasking-service/src/persistency/cassandra (interfaces: ISession,IQuery,IIter,IBatch)

// Package mocks is a generated GoMock package.
package mocks

import (
	gocql "github.com/gocql/gocql"
	gomock "github.com/golang/mock/gomock"
	cassandra "gitlab.connectwisedev.com/platform/platform-tasking-service/src/persistency/cassandra"
	reflect "reflect"
)

// MockISession is a mock of ISession interface
type MockISession struct {
	ctrl     *gomock.Controller
	recorder *MockISessionMockRecorder
}

// MockISessionMockRecorder is the mock recorder for MockISession
type MockISessionMockRecorder struct {
	mock *MockISession
}

// NewMockISession creates a new mock instance
func NewMockISession(ctrl *gomock.Controller) *MockISession {
	mock := &MockISession{ctrl: ctrl}
	mock.recorder = &MockISessionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockISession) EXPECT() *MockISessionMockRecorder {
	return m.recorder
}

// Closed mocks base method
func (m *MockISession) Closed() bool {
	ret := m.ctrl.Call(m, "Closed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// Closed indicates an expected call of Closed
func (mr *MockISessionMockRecorder) Closed() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Closed", reflect.TypeOf((*MockISession)(nil).Closed))
}

// ExecuteBatch mocks base method
func (m *MockISession) ExecuteBatch(arg0 cassandra.IBatch) error {
	ret := m.ctrl.Call(m, "ExecuteBatch", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExecuteBatch indicates an expected call of ExecuteBatch
func (mr *MockISessionMockRecorder) ExecuteBatch(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExecuteBatch", reflect.TypeOf((*MockISession)(nil).ExecuteBatch), arg0)
}

// NewBatch mocks base method
func (m *MockISession) NewBatch(arg0 gocql.BatchType) cassandra.IBatch {
	ret := m.ctrl.Call(m, "NewBatch", arg0)
	ret0, _ := ret[0].(cassandra.IBatch)
	return ret0
}

// NewBatch indicates an expected call of NewBatch
func (mr *MockISessionMockRecorder) NewBatch(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewBatch", reflect.TypeOf((*MockISession)(nil).NewBatch), arg0)
}

// Query mocks base method
func (m *MockISession) Query(arg0 string, arg1 ...interface{}) cassandra.IQuery {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Query", varargs...)
	ret0, _ := ret[0].(cassandra.IQuery)
	return ret0
}

// Query indicates an expected call of Query
func (mr *MockISessionMockRecorder) Query(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockISession)(nil).Query), varargs...)
}

// MockIQuery is a mock of IQuery interface
type MockIQuery struct {
	ctrl     *gomock.Controller
	recorder *MockIQueryMockRecorder
}

// MockIQueryMockRecorder is the mock recorder for MockIQuery
type MockIQueryMockRecorder struct {
	mock *MockIQuery
}

// NewMockIQuery creates a new mock instance
func NewMockIQuery(ctrl *gomock.Controller) *MockIQuery {
	mock := &MockIQuery{ctrl: ctrl}
	mock.recorder = &MockIQueryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIQuery) EXPECT() *MockIQueryMockRecorder {
	return m.recorder
}

// Exec mocks base method
func (m *MockIQuery) Exec() error {
	ret := m.ctrl.Call(m, "Exec")
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec
func (mr *MockIQueryMockRecorder) Exec() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockIQuery)(nil).Exec))
}

// Iter mocks base method
func (m *MockIQuery) Iter() cassandra.IIter {
	ret := m.ctrl.Call(m, "Iter")
	ret0, _ := ret[0].(cassandra.IIter)
	return ret0
}

// Iter indicates an expected call of Iter
func (mr *MockIQueryMockRecorder) Iter() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iter", reflect.TypeOf((*MockIQuery)(nil).Iter))
}

// PageSize mocks base method
func (m *MockIQuery) PageSize(arg0 int) cassandra.IQuery {
	ret := m.ctrl.Call(m, "PageSize", arg0)
	ret0, _ := ret[0].(cassandra.IQuery)
	return ret0
}

// PageSize indicates an expected call of PageSize
func (mr *MockIQueryMockRecorder) PageSize(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PageSize", reflect.TypeOf((*MockIQuery)(nil).PageSize), arg0)
}

// PageState mocks base method
func (m *MockIQuery) PageState(arg0 []byte) cassandra.IQuery {
	ret := m.ctrl.Call(m, "PageState", arg0)
	ret0, _ := ret[0].(cassandra.IQuery)
	return ret0
}

// PageState indicates an expected call of PageState
func (mr *MockIQueryMockRecorder) PageState(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PageState", reflect.TypeOf((*MockIQuery)(nil).PageState), arg0)
}

// Release mocks base method
func (m *MockIQuery) Release() {
	m.ctrl.Call(m, "Release")
}

// Release indicates an expected call of Release
func (mr *MockIQueryMockRecorder) Release() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Release", reflect.TypeOf((*MockIQuery)(nil).Release))
}

// Scan mocks base method
func (m *MockIQuery) Scan(arg0 ...interface{}) error {
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Scan indicates an expected call of Scan
func (mr *MockIQueryMockRecorder) Scan(arg0 ...interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIQuery)(nil).Scan), arg0...)
}

// SetConsistency mocks base method
func (m *MockIQuery) SetConsistency(arg0 gocql.Consistency) {
	m.ctrl.Call(m, "SetConsistency", arg0)
}

// SetConsistency indicates an expected call of SetConsistency
func (mr *MockIQueryMockRecorder) SetConsistency(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetConsistency", reflect.TypeOf((*MockIQuery)(nil).SetConsistency), arg0)
}

// MockIIter is a mock of IIter interface
type MockIIter struct {
	ctrl     *gomock.Controller
	recorder *MockIIterMockRecorder
}

// MockIIterMockRecorder is the mock recorder for MockIIter
type MockIIterMockRecorder struct {
	mock *MockIIter
}

// NewMockIIter creates a new mock instance
func NewMockIIter(ctrl *gomock.Controller) *MockIIter {
	mock := &MockIIter{ctrl: ctrl}
	mock.recorder = &MockIIterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIIter) EXPECT() *MockIIterMockRecorder {
	return m.recorder
}

// Close mocks base method
func (m *MockIIter) Close() error {
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockIIterMockRecorder) Close() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIIter)(nil).Close))
}

// PageState mocks base method
func (m *MockIIter) PageState() []byte {
	ret := m.ctrl.Call(m, "PageState")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// PageState indicates an expected call of PageState
func (mr *MockIIterMockRecorder) PageState() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PageState", reflect.TypeOf((*MockIIter)(nil).PageState))
}

// Scan mocks base method
func (m *MockIIter) Scan(arg0 ...interface{}) bool {
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Scan", varargs...)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Scan indicates an expected call of Scan
func (mr *MockIIterMockRecorder) Scan(arg0 ...interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Scan", reflect.TypeOf((*MockIIter)(nil).Scan), arg0...)
}

// MockIBatch is a mock of IBatch interface
type MockIBatch struct {
	ctrl     *gomock.Controller
	recorder *MockIBatchMockRecorder
}

// MockIBatchMockRecorder is the mock recorder for MockIBatch
type MockIBatchMockRecorder struct {
	mock *MockIBatch
}

// NewMockIBatch creates a new mock instance
func NewMockIBatch(ctrl *gomock.Controller) *MockIBatch {
	mock := &MockIBatch{ctrl: ctrl}
	mock.recorder = &MockIBatchMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIBatch) EXPECT() *MockIBatchMockRecorder {
	return m.recorder
}

// Query mocks base method
func (m *MockIBatch) Query(arg0 string, arg1 ...interface{}) {
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Query", varargs...)
}

// Query indicates an expected call of Query
func (mr *MockIBatchMockRecorder) Query(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockIBatch)(nil).Query), varargs...)
}

// Size mocks base method
func (m *MockIBatch) Size() int {
	ret := m.ctrl.Call(m, "Size")
	ret0, _ := ret[0].(int)
	return ret0
}

// Size indicates an expected call of Size
func (mr *MockIBatchMockRecorder) Size() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Size", reflect.TypeOf((*MockIBatch)(nil).Size))
}
