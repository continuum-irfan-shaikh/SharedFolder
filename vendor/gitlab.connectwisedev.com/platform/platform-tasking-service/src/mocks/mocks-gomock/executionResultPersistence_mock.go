// Code generated by MockGen. DO NOT EDIT.
// Source: gitlab.connectwisedev.com/platform/platform-tasking-service/src/models (interfaces: ExecutionResultPersistence)

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	models "gitlab.connectwisedev.com/platform/platform-tasking-service/src/models"
	gocql "github.com/gocql/gocql"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockExecutionResultPersistence is a mock of ExecutionResultPersistence interface
type MockExecutionResultPersistence struct {
	ctrl     *gomock.Controller
	recorder *MockExecutionResultPersistenceMockRecorder
}

// MockExecutionResultPersistenceMockRecorder is the mock recorder for MockExecutionResultPersistence
type MockExecutionResultPersistenceMockRecorder struct {
	mock *MockExecutionResultPersistence
}

// NewMockExecutionResultPersistence creates a new mock instance
func NewMockExecutionResultPersistence(ctrl *gomock.Controller) *MockExecutionResultPersistence {
	mock := &MockExecutionResultPersistence{ctrl: ctrl}
	mock.recorder = &MockExecutionResultPersistenceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockExecutionResultPersistence) EXPECT() *MockExecutionResultPersistenceMockRecorder {
	return m.recorder
}

// DeleteBatch mocks base method
func (m *MockExecutionResultPersistence) DeleteBatch(arg0 context.Context, arg1 []models.ExecutionResult) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteBatch", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteBatch indicates an expected call of DeleteBatch
func (mr *MockExecutionResultPersistenceMockRecorder) DeleteBatch(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteBatch", reflect.TypeOf((*MockExecutionResultPersistence)(nil).DeleteBatch), arg0, arg1)
}

// GetByTargetAndTaskInstanceIDs mocks base method
func (m *MockExecutionResultPersistence) GetByTargetAndTaskInstanceIDs(arg0 gocql.UUID, arg1 ...gocql.UUID) ([]models.ExecutionResult, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0}
	for _, a := range arg1 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetByTargetAndTaskInstanceIDs", varargs...)
	ret0, _ := ret[0].([]models.ExecutionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByTargetAndTaskInstanceIDs indicates an expected call of GetByTargetAndTaskInstanceIDs
func (mr *MockExecutionResultPersistenceMockRecorder) GetByTargetAndTaskInstanceIDs(arg0 interface{}, arg1 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0}, arg1...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByTargetAndTaskInstanceIDs", reflect.TypeOf((*MockExecutionResultPersistence)(nil).GetByTargetAndTaskInstanceIDs), varargs...)
}

// GetByTaskInstanceIDs mocks base method
func (m *MockExecutionResultPersistence) GetByTaskInstanceIDs(arg0 []gocql.UUID) ([]models.ExecutionResult, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByTaskInstanceIDs", arg0)
	ret0, _ := ret[0].([]models.ExecutionResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByTaskInstanceIDs indicates an expected call of GetByTaskInstanceIDs
func (mr *MockExecutionResultPersistenceMockRecorder) GetByTaskInstanceIDs(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByTaskInstanceIDs", reflect.TypeOf((*MockExecutionResultPersistence)(nil).GetByTaskInstanceIDs), arg0)
}

// Upsert mocks base method
func (m *MockExecutionResultPersistence) Upsert(arg0 context.Context, arg1, arg2 string, arg3 ...models.ExecutionResult) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Upsert", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Upsert indicates an expected call of Upsert
func (mr *MockExecutionResultPersistenceMockRecorder) Upsert(arg0, arg1, arg2 interface{}, arg3 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockExecutionResultPersistence)(nil).Upsert), varargs...)
}
