// Code generated by MockGen. DO NOT EDIT.
// Source: ./usecase.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	gocql "github.com/gocql/gocql"
	gomock "github.com/golang/mock/gomock"
	tasking "gitlab.connectwisedev.com/platform/platform-api-model/clients/model/Golang/resourceModel/tasking"
	entities "gitlab.connectwisedev.com/platform/platform-tasking-service/src/entities"
	models "gitlab.connectwisedev.com/platform/platform-tasking-service/src/models"
	reflect "reflect"
)

// MockUsecase is a mock of Usecase interface
type MockUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockUsecaseMockRecorder
}

// MockUsecaseMockRecorder is the mock recorder for MockUsecase
type MockUsecaseMockRecorder struct {
	mock *MockUsecase
}

// NewMockUsecase creates a new mock instance
func NewMockUsecase(ctrl *gomock.Controller) *MockUsecase {
	mock := &MockUsecase{ctrl: ctrl}
	mock.recorder = &MockUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUsecase) EXPECT() *MockUsecaseMockRecorder {
	return m.recorder
}

// Activate mocks base method
func (m *MockUsecase) Activate(ctx context.Context, tasks []models.Task) error {
	ret := m.ctrl.Call(m, "Activate", ctx, tasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// Activate indicates an expected call of Activate
func (mr *MockUsecaseMockRecorder) Activate(ctx, tasks interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Activate", reflect.TypeOf((*MockUsecase)(nil).Activate), ctx, tasks)
}

// Deactivate mocks base method
func (m *MockUsecase) Deactivate(ctx context.Context, tasks []models.Task) error {
	ret := m.ctrl.Call(m, "Deactivate", ctx, tasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deactivate indicates an expected call of Deactivate
func (mr *MockUsecaseMockRecorder) Deactivate(ctx, tasks interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deactivate", reflect.TypeOf((*MockUsecase)(nil).Deactivate), ctx, tasks)
}

// PreExecution mocks base method
func (m *MockUsecase) PreExecution(triggerType string, task models.Task) error {
	ret := m.ctrl.Call(m, "PreExecution", triggerType, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// PreExecution indicates an expected call of PreExecution
func (mr *MockUsecaseMockRecorder) PreExecution(triggerType, task interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreExecution", reflect.TypeOf((*MockUsecase)(nil).PreExecution), triggerType, task)
}

// PostExecution mocks base method
func (m *MockUsecase) PostExecution(triggerType string, task models.Task) error {
	ret := m.ctrl.Call(m, "PostExecution", triggerType, task)
	ret0, _ := ret[0].(error)
	return ret0
}

// PostExecution indicates an expected call of PostExecution
func (mr *MockUsecaseMockRecorder) PostExecution(triggerType, task interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostExecution", reflect.TypeOf((*MockUsecase)(nil).PostExecution), triggerType, task)
}

// IsApplicable mocks base method
func (m *MockUsecase) IsApplicable(ctx context.Context, task models.Task, payload tasking.TriggerExecutionPayload) bool {
	ret := m.ctrl.Call(m, "IsApplicable", ctx, task, payload)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsApplicable indicates an expected call of IsApplicable
func (mr *MockUsecaseMockRecorder) IsApplicable(ctx, task, payload interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicable", reflect.TypeOf((*MockUsecase)(nil).IsApplicable), ctx, task, payload)
}

// GetActiveTriggers mocks base method
func (m *MockUsecase) GetActiveTriggers(ctx context.Context) ([]entities.ActiveTrigger, error) {
	ret := m.ctrl.Call(m, "GetActiveTriggers", ctx)
	ret0, _ := ret[0].([]entities.ActiveTrigger)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetActiveTriggers indicates an expected call of GetActiveTriggers
func (mr *MockUsecaseMockRecorder) GetActiveTriggers(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActiveTriggers", reflect.TypeOf((*MockUsecase)(nil).GetActiveTriggers), ctx)
}

// GetActiveTriggersByTaskID mocks base method
func (m *MockUsecase) GetActiveTriggersByTaskID(partnerID string, taskID gocql.UUID) ([]entities.ActiveTrigger, error) {
	ret := m.ctrl.Call(m, "GetActiveTriggersByTaskID", partnerID, taskID)
	ret0, _ := ret[0].([]entities.ActiveTrigger)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetActiveTriggersByTaskID indicates an expected call of GetActiveTriggersByTaskID
func (mr *MockUsecaseMockRecorder) GetActiveTriggersByTaskID(partnerID, taskID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetActiveTriggersByTaskID", reflect.TypeOf((*MockUsecase)(nil).GetActiveTriggersByTaskID), partnerID, taskID)
}

// GetTask mocks base method
func (m *MockUsecase) GetTask(ctx context.Context, taskID gocql.UUID) (models.Task, error) {
	ret := m.ctrl.Call(m, "GetTask", ctx, taskID)
	ret0, _ := ret[0].(models.Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTask indicates an expected call of GetTask
func (mr *MockUsecaseMockRecorder) GetTask(ctx, taskID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTask", reflect.TypeOf((*MockUsecase)(nil).GetTask), ctx, taskID)
}

// DeleteActiveTriggers mocks base method
func (m *MockUsecase) DeleteActiveTriggers(triggers []entities.ActiveTrigger) error {
	ret := m.ctrl.Call(m, "DeleteActiveTriggers", triggers)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteActiveTriggers indicates an expected call of DeleteActiveTriggers
func (mr *MockUsecaseMockRecorder) DeleteActiveTriggers(triggers interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteActiveTriggers", reflect.TypeOf((*MockUsecase)(nil).DeleteActiveTriggers), triggers)
}

// ActiveTriggersReopening mocks base method
func (m *MockUsecase) ActiveTriggersReopening(ctx context.Context) {
	m.ctrl.Call(m, "ActiveTriggersReopening", ctx)
}

// ActiveTriggersReopening indicates an expected call of ActiveTriggersReopening
func (mr *MockUsecaseMockRecorder) ActiveTriggersReopening(ctx interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ActiveTriggersReopening", reflect.TypeOf((*MockUsecase)(nil).ActiveTriggersReopening), ctx)
}

// MockHandler is a mock of Handler interface
type MockHandler struct {
	ctrl     *gomock.Controller
	recorder *MockHandlerMockRecorder
}

// MockHandlerMockRecorder is the mock recorder for MockHandler
type MockHandlerMockRecorder struct {
	mock *MockHandler
}

// NewMockHandler creates a new mock instance
func NewMockHandler(ctrl *gomock.Controller) *MockHandler {
	mock := &MockHandler{ctrl: ctrl}
	mock.recorder = &MockHandlerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockHandler) EXPECT() *MockHandlerMockRecorder {
	return m.recorder
}

// Activate mocks base method
func (m *MockHandler) Activate(ctx context.Context, exactType string, tasks []models.Task) error {
	ret := m.ctrl.Call(m, "Activate", ctx, exactType, tasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// Activate indicates an expected call of Activate
func (mr *MockHandlerMockRecorder) Activate(ctx, exactType, tasks interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Activate", reflect.TypeOf((*MockHandler)(nil).Activate), ctx, exactType, tasks)
}

// Deactivate mocks base method
func (m *MockHandler) Deactivate(ctx context.Context, exactType string, tasks []models.Task) error {
	ret := m.ctrl.Call(m, "Deactivate", ctx, exactType, tasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// Deactivate indicates an expected call of Deactivate
func (mr *MockHandlerMockRecorder) Deactivate(ctx, exactType, tasks interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Deactivate", reflect.TypeOf((*MockHandler)(nil).Deactivate), ctx, exactType, tasks)
}

// Update mocks base method
func (m *MockHandler) Update(ctx context.Context, exactType string, tasks []models.Task) error {
	ret := m.ctrl.Call(m, "Update", ctx, exactType, tasks)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update
func (mr *MockHandlerMockRecorder) Update(ctx, exactType, tasks interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockHandler)(nil).Update), ctx, exactType, tasks)
}

// IsApplicable mocks base method
func (m *MockHandler) IsApplicable(ctx context.Context, task models.Task, payload tasking.TriggerExecutionPayload) bool {
	ret := m.ctrl.Call(m, "IsApplicable", ctx, task, payload)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsApplicable indicates an expected call of IsApplicable
func (mr *MockHandlerMockRecorder) IsApplicable(ctx, task, payload interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsApplicable", reflect.TypeOf((*MockHandler)(nil).IsApplicable), ctx, task, payload)
}

// GetTask mocks base method
func (m *MockHandler) GetTask(ctx context.Context, taskID gocql.UUID) (models.Task, error) {
	ret := m.ctrl.Call(m, "GetTask", ctx, taskID)
	ret0, _ := ret[0].(models.Task)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTask indicates an expected call of GetTask
func (mr *MockHandlerMockRecorder) GetTask(ctx, taskID interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTask", reflect.TypeOf((*MockHandler)(nil).GetTask), ctx, taskID)
}

// PreExecution mocks base method
func (m *MockHandler) PreExecution(task models.Task) error {
	ret := m.ctrl.Call(m, "PreExecution", task)
	ret0, _ := ret[0].(error)
	return ret0
}

// PreExecution indicates an expected call of PreExecution
func (mr *MockHandlerMockRecorder) PreExecution(task interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PreExecution", reflect.TypeOf((*MockHandler)(nil).PreExecution), task)
}

// PostExecution mocks base method
func (m *MockHandler) PostExecution(task models.Task) error {
	ret := m.ctrl.Call(m, "PostExecution", task)
	ret0, _ := ret[0].(error)
	return ret0
}

// PostExecution indicates an expected call of PostExecution
func (mr *MockHandlerMockRecorder) PostExecution(task interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PostExecution", reflect.TypeOf((*MockHandler)(nil).PostExecution), task)
}

// MockDefinitionUseCase is a mock of DefinitionUseCase interface
type MockDefinitionUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockDefinitionUseCaseMockRecorder
}

// MockDefinitionUseCaseMockRecorder is the mock recorder for MockDefinitionUseCase
type MockDefinitionUseCaseMockRecorder struct {
	mock *MockDefinitionUseCase
}

// NewMockDefinitionUseCase creates a new mock instance
func NewMockDefinitionUseCase(ctrl *gomock.Controller) *MockDefinitionUseCase {
	mock := &MockDefinitionUseCase{ctrl: ctrl}
	mock.recorder = &MockDefinitionUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockDefinitionUseCase) EXPECT() *MockDefinitionUseCaseMockRecorder {
	return m.recorder
}

// ImportExternalTriggers mocks base method
func (m *MockDefinitionUseCase) ImportExternalTriggers(defs []entities.TriggerDefinition) error {
	ret := m.ctrl.Call(m, "ImportExternalTriggers", defs)
	ret0, _ := ret[0].(error)
	return ret0
}

// ImportExternalTriggers indicates an expected call of ImportExternalTriggers
func (mr *MockDefinitionUseCaseMockRecorder) ImportExternalTriggers(defs interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ImportExternalTriggers", reflect.TypeOf((*MockDefinitionUseCase)(nil).ImportExternalTriggers), defs)
}

// GetTriggerTypes mocks base method
func (m *MockDefinitionUseCase) GetTriggerTypes() ([]entities.TriggerDefinition, error) {
	ret := m.ctrl.Call(m, "GetTriggerTypes")
	ret0, _ := ret[0].([]entities.TriggerDefinition)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetTriggerTypes indicates an expected call of GetTriggerTypes
func (mr *MockDefinitionUseCaseMockRecorder) GetTriggerTypes() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTriggerTypes", reflect.TypeOf((*MockDefinitionUseCase)(nil).GetTriggerTypes))
}
